# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import numpy as np
import pdfplumber
import io
import re

"""
An application for reconciling credit card statements against Mobills exports.

This Streamlit web app allows a user to upload two files – one representing
their monthly credit card statement and another representing a Mobills export –
and then compares the two sets of transactions.  It identifies entries that
appear in Mobills but not on the statement, as well as entries that appear on
the statement but not in Mobills.  A reconciliation summary table details
unmatched transactions and provides totals for each source.

The app supports CSV, Excel (XLS/XLSX) and PDF documents.  When PDF files
are uploaded a simple text extraction routine attempts to identify rows
containing dates and currency values using regular expressions.  While this
automatic extraction works on many well‑formatted card statements, users
should verify the results and adjust the date/value column selections if
necessary.  CSV and Excel files are parsed with pandas.

To ensure accurate matching, dates are normalised to datetime objects and
values are converted to floating point numbers.  Transactions match only
when both the date and the value coincide exactly.  Duplicate values on
the same day are handled correctly – the algorithm pairs each statement row
with the first unmatched Mobills row of equal date and value.
"""


def parse_csv_or_excel(uploaded_file: io.BytesIO) -> pd.DataFrame:
    """Read a CSV or Excel file into a DataFrame.

    This helper attempts to handle CSV files that may use semicolons as
    delimiters (common in Brazilian exports) as well as standard comma
    delimited files.  It tries both UTF‑8 and Latin‑1 encodings.  For
    Excel files it relies on pandas' read_excel.

    Parameters
    ----------
    uploaded_file : BytesIO
        File‑like object returned by st.file_uploader.

    Returns
    -------
    DataFrame
        Parsed data.
    """
    filename = uploaded_file.name.lower()
    if filename.endswith(".csv"):
        # Attempt to detect delimiter by inspecting the first line
        # Many Brazilian CSV exports use semicolon instead of comma
        # We'll read a small sample to compare the counts
        for encoding in ["utf-8", "latin-1"]:
            uploaded_file.seek(0)
            try:
                # Peek at the first line
                sample_bytes = uploaded_file.read(1024)
                try:
                    sample = sample_bytes.decode(encoding)
                except Exception:
                    continue
                uploaded_file.seek(0)
                first_line = sample.split("\n")[0]
                # Determine which delimiter is likely
                semi_count = first_line.count(";")
                comma_count = first_line.count(",")
                # Use semicolon if it appears more times than comma
                delimiter = ";" if semi_count > comma_count else ","
                return pd.read_csv(uploaded_file, encoding=encoding, sep=delimiter)
            except Exception:
                continue
        # Fallback: try default read_csv
        uploaded_file.seek(0)
        return pd.read_csv(uploaded_file)
    else:
        # Excel file: rely on openpyxl engine where available
        uploaded_file.seek(0)
        try:
            return pd.read_excel(uploaded_file, engine="openpyxl")
        except Exception:
            uploaded_file.seek(0)
            return pd.read_excel(uploaded_file)


def extract_transactions_from_pdf(uploaded_file: io.BytesIO) -> pd.DataFrame:
    """Extract possible date and value rows from a PDF statement.

    The extraction looks for lines containing a date in the Brazilian
    day/month/year format and a value (with comma or dot decimal).  It then
    assembles these into a simple DataFrame with two columns: "Date" and
    "Value".  Users may need to adjust column selection after import.

    Parameters
    ----------
    uploaded_file : BytesIO
        PDF file uploaded by the user.

    Returns
    -------
    DataFrame
        DataFrame with guessed date and value columns.
    """
    rows = []
    date_pattern = re.compile(r"\b(\d{1,2}\/\d{1,2}\/\d{2,4})\b")
    value_pattern = re.compile(r"(-?\d+[\.\d]*,\d{2})|(-?\d+[\d]*\.\d{2})")
    with pdfplumber.open(uploaded_file) as pdf:
        for page in pdf.pages:
            text = page.extract_text() or ""
            for line in text.split("\n"):
                date_match = date_pattern.search(line)
                value_match = value_pattern.search(line)
                if date_match and value_match:
                    date_str = date_match.group(1)
                    val_str = value_match.group(0)
                    rows.append({"Date": date_str.strip(), "Value": val_str.strip(), "Line": line.strip()})
    return pd.DataFrame(rows)


def detect_column(df: pd.DataFrame, keywords: list[str]) -> str | None:
    """Attempt to detect a column by a list of keyword substrings.

    If exactly one column name contains any of the provided keywords (case
    insensitive) then that column name is returned.  Otherwise None.
    """
    matches = [col for col in df.columns if any(k.lower() in str(col).lower() for k in keywords)]
    if len(matches) == 1:
        return matches[0]
    return None


def normalise_numeric(value: any) -> float | None:
    """Convert a variety of numeric formats to a float.

    Handles Brazilian formats where the thousand separator is a dot and the
    decimal separator is a comma, as well as standard international formats.
    Returns None if the value cannot be interpreted as a number.
    """
    if value is None or (isinstance(value, float) and np.isnan(value)):
        return None
    s = str(value).strip()
    # Remove currency symbols and spaces
    s = re.sub(r"[Rr\$\s]", "", s)
    # If it uses comma as decimal separator and dot as thousand separator
    if "," in s and s.count(",") == 1:
        s = s.replace(".", "").replace(",", ".")
    # Remove any remaining thousands separators (commas)
    if s.count(",") > 1:
        s = s.replace(",", "")
    try:
        return float(s)
    except ValueError:
        return None


def reconcile_transactions(
    df_fatura: pd.DataFrame,
    df_mobills: pd.DataFrame,
    date_col_f: str,
    value_col_f: str,
    date_col_m: str,
    value_col_m: str,
) -> tuple[pd.DataFrame, pd.DataFrame, float, float, float]:
    """Match transactions by date and amount.

    Returns the unmatched rows from each DataFrame and the totals for
    reconciliation.
    """
    # Prepare copies
    f = df_fatura.copy().reset_index(drop=True)
    m = df_mobills.copy().reset_index(drop=True)

    # Normalise dates
    f["_date"] = pd.to_datetime(f[date_col_f], errors="coerce", dayfirst=True)
    m["_date"] = pd.to_datetime(m[date_col_m], errors="coerce", dayfirst=True)

    # Normalise values
    f["_value"] = f[value_col_f].apply(normalise_numeric)
    m["_value"] = m[value_col_m].apply(normalise_numeric)

    # Filter out rows with missing date or value
    f_valid = f.dropna(subset=["_date", "_value"]).copy()
    m_valid = m.dropna(subset=["_date", "_value"]).copy()

    f_valid["_matched"] = False
    m_valid["_matched"] = False

    # Perform matching: For each statement row, find first unmatched mobills row with same date and value
    for idx_f, row_f in f_valid.iterrows():
        if row_f["_matched"]:
            continue
        candidates = m_valid[(m_valid["_matched"] == False) & (m_valid["_date"] == row_f["_date"]) & (m_valid["_value"] == row_f["_value"])]
        if len(candidates) > 0:
            # Mark the first candidate as matched
            idx_m = candidates.index[0]
            f_valid.at[idx_f, "_matched"] = True
            m_valid.at[idx_m, "_matched"] = True
    # Unmatched
    unmatched_f = f_valid[~f_valid["_matched"]]
    unmatched_m = m_valid[~m_valid["_matched"]]

    # Compute totals (including all valid rows)
    total_f = f_valid["_value"].sum()
    total_m = m_valid["_value"].sum()
    difference = total_f - total_m
    return unmatched_f, unmatched_m, total_f, total_m, difference


def main():
    st.set_page_config(page_title="Conciliador de Fatura x Mobills", layout="wide")
    # Use an ASCII-only title to avoid encoding issues during deployment
    st.title("Conciliador de Fatura de Cartao x Mobills")
    # Use ASCII-only text for the introductory section to avoid encoding problems
    st.markdown(
        """
        Este aplicativo permite comparar os lancamentos da fatura do seu cartao de credito
        com os lancamentos exportados do Mobills. Ele identifica diferencas e ajuda a
        garantir que ambos os relatorios estejam conciliados.

        **Como funciona:**

        1. **Envie os arquivos** da fatura e do Mobills. Sao aceitos formatos CSV, XLSX,
           XLS e PDF. O aplicativo tentara extrair as colunas de data e valor automaticamente.
           Caso nao consiga, voce podera seleciona-las manualmente.
        2. **Revise as colunas detectadas** e ajuste se necessario.
        3. **Clique em "Conciliar"** para gerar o relatorio de inconsistencias.

        As transacoes sao consideradas conciliadas somente quando a **data e o valor
        coincidem exatamente**. Valores duplicados no mesmo dia sao tratados de forma
        individual.
        """
    )

    # Sidebar: labels without accents to avoid encoding issues
    st.sidebar.header("Upload de Arquivos")
    fatura_file = st.sidebar.file_uploader("Fatura do cartao", type=["csv", "xls", "xlsx", "pdf"])
    mobills_file = st.sidebar.file_uploader("Relatorio do Mobills", type=["csv", "xls", "xlsx", "pdf"])

    df_fatura, df_mobills = None, None

    if fatura_file is not None:
        ext = fatura_file.name.lower().split(".")[-1]
        if ext == "pdf":
            df_fatura = extract_transactions_from_pdf(fatura_file)
        else:
            df_fatura = parse_csv_or_excel(fatura_file)
        st.write("### Pre-visualizacao da Fatura", df_fatura.head())

    if mobills_file is not None:
        ext = mobills_file.name.lower().split(".")[-1]
        if ext == "pdf":
            df_mobills = extract_transactions_from_pdf(mobills_file)
        else:
            df_mobills = parse_csv_or_excel(mobills_file)
        st.write("### Pre-visualizacao do Mobills", df_mobills.head())

    # If both dataframes exist, allow column selection
    if df_fatura is not None and df_mobills is not None and not df_fatura.empty and not df_mobills.empty:
        st.sidebar.header("Configuracao de Colunas")
        # Attempt to detect columns automatically
        default_date_f = detect_column(df_fatura, ["data", "date", "dia"])
        default_value_f = detect_column(df_fatura, ["valor", "value", "amount"])
        default_date_m = detect_column(df_mobills, ["data", "date", "dia"])
        default_value_m = detect_column(df_mobills, ["valor", "value", "amount"])

        date_col_f = st.sidebar.selectbox("Coluna de Data (Fatura)", df_fatura.columns, index=(df_fatura.columns.tolist().index(default_date_f) if default_date_f in df_fatura.columns else 0))
        value_col_f = st.sidebar.selectbox("Coluna de Valor (Fatura)", df_fatura.columns, index=(df_fatura.columns.tolist().index(default_value_f) if default_value_f in df_fatura.columns else 1 if df_fatura.shape[1] > 1 else 0))
        date_col_m = st.sidebar.selectbox("Coluna de Data (Mobills)", df_mobills.columns, index=(df_mobills.columns.tolist().index(default_date_m) if default_date_m in df_mobills.columns else 0))
        value_col_m = st.sidebar.selectbox("Coluna de Valor (Mobills)", df_mobills.columns, index=(df_mobills.columns.tolist().index(default_value_m) if default_value_m in df_mobills.columns else 1 if df_mobills.shape[1] > 1 else 0))

        # Identify negative values in the fatura (possible payment of previous month)
        # Only compute after the user selects which columns correspond to date and value
        try:
            # Apply numeric conversion to detect negatives
            tmp_vals = df_fatura[value_col_f].apply(normalise_numeric)
            negatives_df = df_fatura[tmp_vals < 0]
        except Exception:
            negatives_df = pd.DataFrame()

        ignore_indices: list[int] = []
        if not negatives_df.empty:
            # Build labels for the sidebar multiselect
            neg_options = []
            for idx, row in negatives_df.iterrows():
                # Use date and value for display
                try:
                    date_label = str(row[date_col_f])
                except Exception:
                    date_label = ""
                val_label = str(row[value_col_f])
                # Include a description column if present
                desc = ""
                for col_name in ["Descricao", "Descrição", "Estabelecimento", "Descricao"]:
                    if col_name in df_fatura.columns:
                        desc = str(row[col_name])
                        break
                label = f"{date_label} | {val_label}"
                if desc:
                    label += f" | {desc}"
                neg_options.append(label)
            selected_neg = st.sidebar.multiselect(
                "Selecione valores negativos da fatura a ignorar (pagamento do mes anterior)", options=neg_options
            )
            # Map selected labels back to indices
            ignore_indices = [negatives_df.index[i] for i, lbl in enumerate(neg_options) if lbl in selected_neg]

        if st.sidebar.button("Conciliar"):
            with st.spinner("Conciliando... Aguarde um momentinho enquanto alinhamos as estrelas 🔮"):
                # Drop selected negative payment rows before reconciliation
                df_fatura_filtered = df_fatura.drop(index=ignore_indices) if ignore_indices else df_fatura
                unmatched_f, unmatched_m, total_f, total_m, difference = reconcile_transactions(
                    df_fatura_filtered, df_mobills, date_col_f, value_col_f, date_col_m, value_col_m
                )
            st.success("Conciliação finalizada!")
            st.write("## Resultados da Conciliação")
            col1, col2, col3 = st.columns(3)
            col1.metric("Total na Fatura", f"R$ {total_f:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."))
            col2.metric("Total no Mobills", f"R$ {total_m:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."))
            diff_str = f"R$ {difference:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
            col3.metric("Diferença (Fatura - Mobills)", diff_str, delta="")

            st.write(
                """
                **Lancamentos presentes na fatura mas ausentes no Mobills:**
                Estes devem ser lancados no Mobills ou questionados junto ao banco se nao forem devidos.
                """
            )
            st.dataframe(unmatched_f.drop(columns=["_date", "_value", "_matched"], errors="ignore"), use_container_width=True)

            st.write(
                """
                **Lancamentos presentes no Mobills mas ausentes na fatura:**
                Estes podem ter sido lancamentos duplicados ou agendados que ainda nao cairam na fatura. Verifique se faz sentido mante-los.
                """
            )
            st.dataframe(unmatched_m.drop(columns=["_date", "_value", "_matched"], errors="ignore"), use_container_width=True)

            # Offer manual reconciliation for close dates/values
            if not unmatched_f.empty and not unmatched_m.empty:
                with st.expander("Conciliação manual por aproximação de data"):
                    tol = st.number_input(
                        "Tolerancia de dias para considerar datas proximas", min_value=0, max_value=5, value=1, step=1
                    )
                    candidates: list[tuple[str, int, int]] = []
                    # Build candidate pairs based on identical values and date proximity
                    for idx_f, row_f in unmatched_f.iterrows():
                        for idx_m, row_m in unmatched_m.iterrows():
                            try:
                                val_f = row_f["_value"]
                                val_m = row_m["_value"]
                                date_f = row_f["_date"]
                                date_m = row_m["_date"]
                            except Exception:
                                continue
                            if val_f == val_m:
                                try:
                                    delta_days = abs((date_f - date_m).days)
                                except Exception:
                                    continue
                                if delta_days <= tol:
                                    # Create a human readable label
                                    date_f_str = date_f.strftime("%d/%m/%Y") if pd.notna(date_f) else ""
                                    date_m_str = date_m.strftime("%d/%m/%Y") if pd.notna(date_m) else ""
                                    label = f"Fatura {date_f_str} ↔ Mobills {date_m_str} | Valor: R$ {val_f:.2f}"
                                    candidates.append((label, idx_f, idx_m))
                    if candidates:
                        selected_labels = st.multiselect(
                            "Selecione os pares a conciliar manualmente", [c[0] for c in candidates]
                        )
                        if selected_labels and st.button("Aplicar conciliacoes manuais"):
                            # Determine which indices to drop
                            drop_f: list[int] = []
                            drop_m: list[int] = []
                            for lbl in selected_labels:
                                for cand_label, f_idx, m_idx in candidates:
                                    if cand_label == lbl:
                                        drop_f.append(f_idx)
                                        drop_m.append(m_idx)
                                        break
                            # Remove the selected pairs from unmatched lists
                            if drop_f:
                                unmatched_f.drop(index=drop_f, inplace=True, errors="ignore")
                            if drop_m:
                                unmatched_m.drop(index=drop_m, inplace=True, errors="ignore")
                            st.success("Conciliacoes manuais aplicadas. Veja as listas atualizadas abaixo.")
                            st.write("### Fatura restante apos conciliacoes manuais")
                            st.dataframe(
                                unmatched_f.drop(columns=["_date", "_value", "_matched"], errors="ignore"),
                                use_container_width=True,
                            )
                            st.write("### Mobills restante apos conciliacoes manuais")
                            st.dataframe(
                                unmatched_m.drop(columns=["_date", "_value", "_matched"], errors="ignore"),
                                use_container_width=True,
                            )
                    else:
                        st.info("Nenhum par de valor identico encontrado dentro da tolerancia de dias.")

            # Provide download buttons for unmatched transactions
            csv_unmatched_f = unmatched_f.to_csv(index=False).encode("utf-8")
            csv_unmatched_m = unmatched_m.to_csv(index=False).encode("utf-8")
            st.download_button(
                label="⬇️ Baixar inconsistencias da Fatura", data=csv_unmatched_f, file_name="fatura_nao_conciliada.csv", mime="text/csv"
            )
            st.download_button(
                label="⬇️ Baixar inconsistencias do Mobills", data=csv_unmatched_m, file_name="mobills_nao_conciliado.csv", mime="text/csv"
            )

            st.markdown(
                """
                _Obs.: Caso os totais ainda nao coincidam apos os ajustes, verifique se ha lancamentos parcelados
                com datas futuras ou se a fatura exportada corresponde ao mesmo periodo dos lancamentos do Mobills._
                """
            )
        else:
            st.info("Selecione as colunas e clique em \"Conciliar\" para iniciar o cruzamento.")
    elif (fatura_file is not None) ^ (mobills_file is not None):
        st.warning("Envie ambos os arquivos para prosseguir com a conciliação.")

    # Footer
    st.markdown("""---
    Desenvolvido com amor para simplificar sua vida financeira.
    """)


if __name__ == "__main__":
    main()